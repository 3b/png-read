(in-package :png-read)

(defgeneric decode-data (colour-type data png-state))

(defmethod decode-data ((colour-type (eql :greyscale)) data png-state)
  (let ((h (height png-state))
	(w (width png-state))
	(bd (bit-depth png-state)))
    (let ((bda (min 1 (/ bd 8))))
      (setf (image-data png-state)
	    (make-array (list w h) :element-type `(unsigned-byte ,bd)))
      (let ((filtered-scanline-length (1+ (* bda w 4))))
	(let ((scanlines (make-array h)))
	  (iter (for i from 0 below h)
		(setf (aref scanlines i) (subseq data
						 (* i filtered-scanline-length)
						 (* (1+ i) filtered-scanline-length)))))))))

(defmethod decode-data ((colour-type (eql :truecolor-alpha)) data png-state)
  (let ((h (height png-state))
	(w (width png-state))
	(bd (bit-depth png-state)))
    (let ((bda (/ bd 8)))
     (setf (image-data png-state)
	   (make-array (list w h 4) :element-type `(unsigned-byte ,bd)))
     (let ((scanlines (get-scanlines data (1+ (* bda w 4)))))
       (unfilter-scanlines scanlines (* bda 4))
       (let ((image-data (image-data png-state)))
	 (iter (for scanline in-vector scanlines with-index k)
	       (iter (for x in-vector scanline from 1 with-index xi by bda)
		     (for y from 0)
		     (setf (aref image-data (floor (1- xi) (* bda 4)) k (mod y 4))
			   (big-endian-vector-to-integer (subseq scanline xi (+ xi bda)))))))
       png-state))))

(defun get-scanlines (data h filtered-scanline-length)
  (let ((scanlines (make-array h)))
   (iter (for i from 0 below h)
	 (setf (aref scanlines i) (subseq data
					  (* i filtered-scanline-length)
					  (* (1+ i) filtered-scanline-length))))))

(defun sub-byte (xi scanline pixel-length)
  (if (> xi pixel-length)
      (aref scanline (- xi pixel-length))
      0))

(defun up-byte (xi k scanlines)
  (if (zerop k)
      0
      (aref (aref scanlines (1- k)) xi)))

(defun subup-byte (xi k scanlines pixel-length)
  (if (or (zerop k)
	  (<= xi pixel-length))
      0
      (aref (aref scanlines (1- k)) (- xi pixel-length))))

(defun paeth-predictor (xi k scanlines pixel-length)
  (let ((scanline (aref scanlines k)))
    (let ((a (sub-byte xi scanline pixel-length))
	  (b (up-byte xi k scanlines))
	  (c (subup-byte xi k scanlines pixel-length)))
      (let ((p (- (+ a
		     b)
		  c)))
	(let ((pa (abs (- p a)))
	      (pb (abs (- p b)))
	      (pc (abs (- p c))))
	  (cond ((and (<= pa pb)
		      (<= pa pc))
		 a)
		((<= pb pc)
		 b)
		(t c)))))))

(defun unfilter-scanlines (scanlines pixel-length)
  (iter (for scanline in-vector scanlines with-index k)
	(print (aref scanline 0))
	(ecase (aref scanline 0)
	  (0 nil)
	  (1 (iter (for x in-vector scanline from 1 with-index xi)
		   (setf (aref scanline xi)
			 (mod (+ x (sub-byte xi scanline pixel-length)) 256))))
	  (2 (iter (for x in-vector scanline from 1 with-index xi)
		   (setf (aref scanline xi)
			 (mod (+ x (up-byte xi k scanlines)) 256))))
	  (3 (iter (for x in-vector scanline from 1 with-index xi)
		   (setf (aref scanline xi)
			 (mod (+ x (floor (+ (sub-byte xi scanline pixel-length)
					     (up-byte xi k scanlines))
					  2))
			      256))))
	  (4 (iter (for x in-vector scanline from 1 with-index xi)
		   (setf (aref scanline xi)
			 (mod (+ x (paeth-predictor xi k scanlines pixel-length))
			      256)))))))

(defun finish-decoding (png-state)
  (let ((decompressed-data (decompress nil :zlib (datastream png-state))))
    (decode-data (colour-type png-state) decompressed-data png-state)
    (values (image-data png-state)
	    png-state)))
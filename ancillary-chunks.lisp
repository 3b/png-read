(in-package :png-read)

(defgeneric parse-ancillary-chunk (chunk-type chunk-data)
  (:method (chunk-type chunk-data)
    (warn "Unknown ancillary chunk ~a." chunk-type)))

(defun build-transparency-map (png-state)
  (let ((w (width png-state))
	(h (height png-state))
	(ct (colour-type png-state))
	(imd (image-data png-state))
	(transp (transparency png-state)))
   (let ((t-map (make-array (list w h))))
     (iter (for i from 0 below w)
	   (iter (for j from 0 below h)
		 (setf (aref t-map i j)
		       (ecase ct
			 (0 (if (eql (aref imd i j) transp)
				0
				255))
			 (2 (if (iter (for k from 0 to 2)
				      (always (eql (aref imd i j k)
						   (aref transp k))))
				0
				255))))))
     (setf (transparency png-state) t-map))))

(defmethod parse-ancillary-chunk ((chunk-type (eql '|tRNS|)) chunk-data)
  (ecase (colour-type *png-state*)
    (0 (setf (transparency *png-state*)
	     (big-endian-vector-to-integer chunk-data)))
    (2 (setf (transparency *png-state*)
	     (vector (big-endian-vector-to-integer (subseq chunk-data 0 2))
		     (big-endian-vector-to-integer (subseq chunk-data 2 4))
		     (big-endian-vector-to-integer (subseq chunk-data 4 6)))))
    (3 (setf (transparency *png-state*)
	     chunk-data)))
  (when (or (eql (colour-type *png-state*) 0)
	    (eql (colour-type *png-state*) 2))
    (push #'build-transparency-map (postprocess-ancillaries *png-state*))))
